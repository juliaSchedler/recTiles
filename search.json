[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "recTiles",
    "section": "",
    "text": "Fragmenting Parallelepipeds into Signed Tilings\nThis work is an introductory and visual exploration of Alex McDonough and Joseph Dolittle’s paper (see below). For something which is so visually stimulating, the paper is quite rigorous (it is, after all, a math paper). This page is dedicated to accessible presentations of the content with lots of pretty pictures for those of us too lazy to engage with the rigor required to engage mathematically with our world.\n\n\n\n\n\n\nFragmenting Any Parallelepiped into a Signed Tiling\n\n\n\n\n\nIt is broadly known that any parallelepiped tiles space by translating copies of itself along its edges. In earlier work relating to higher-dimensional sandpile groups, the second author discovered a novel construction which fragments the parallelpiped into a collection of smaller tiles. These tiles fill space with the same symmetry as the larger parallelepiped. Their volumes are equal to the components of the multi-row Laplace determinant expansion, so this construction only works when all these signs are non-negative (or non-positive).\nIn this work, we extend the construction to work for all parallelepipeds, without requiring the non-negative condition. This naturally gives tiles with negative volume, which we understand to mean canceling out tiles with positive volume. In fact, with this cancellation, we prove that every point in space is contained in exactly one more tile with positive volume than tile with negative volume. This is a natural definition for a signed tiling.\nOur main technique is to show that the net number of signed tiles doesn’t change as a point moves through space. This is a relatively indirect proof method, and the underlying structure of these tilings remains mysterious.\nLink to ArXiv\n\n\n\nWe hope to develop an app that will allow you to specify a matrix or parallelepiped and then effortlessly enjoy some visualizations of the tiling. For now, we work with static examples to develop code prototypes.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "handdrawn.html#hand-drawn",
    "href": "handdrawn.html#hand-drawn",
    "title": "Julia’s First Tiles",
    "section": "Hand-drawn",
    "text": "Hand-drawn\n\nFirst Tile\n\n\n\nActually I did this one second, but this is the first matrix I chose. Alex suggested I change to the one visualized next.\n\n\n\\[\nM = \\begin{bmatrix}2 & 1\\\\ -1 & 1\\end{bmatrix}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\nSecond Tile\n\n\n\nThe second tiling, actually the very first that I drew (well, the first I drew correctly-- see my mistake?)\n\n\n\\[\nM = \\begin{bmatrix} 2 & 5\\\\ -1 & 3\\end{bmatrix}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\nThird Tile\n\n\n\nThe drawing for the third tiling. I did this one for fun by myself! I chose big numbers so I could have space to write out coordinates and work out some math for the purposes of coding it up.\n\n\n\\[\nM = \\begin{bmatrix} 8& 5\\\\ -4 & 3\\end{bmatrix}\n\\]",
    "crumbs": [
      "Julias first tiles"
    ]
  },
  {
    "objectID": "handdrawn.html#computer-generated",
    "href": "handdrawn.html#computer-generated",
    "title": "Julia’s First Tiles",
    "section": "Computer-generated",
    "text": "Computer-generated\n\nFourth Tile\n\\[\nM = \\begin{bmatrix} 3 & 3\\\\ -3 & 3\\end{bmatrix}\n\\]\n\n\nCode\nlibrary(ggplot2)\n## original coordinates\nA &lt;- matrix(c(3, -3), ncol = 1)\nB &lt;- matrix(c(3, 3), ncol = 1)\n\n## coordinates for 4 copies/combos \ncopies &lt;- -10:10\ncoefs &lt;- expand.grid(copies, copies)\n\nx.coords &lt;- coefs$Var1*A[1] + coefs$Var2*B[1]\ny.coords &lt;- coefs$Var1*A[2] + coefs$Var2*B[2]\n\nplot.dat &lt;- data.frame(x = x.coords, y = y.coords)\np &lt;- ggplot(data = plot.dat, aes(x = x, y = y)) +\n    geom_point() + \n    ylim(c(-14, 7)) +\n    xlim(c(-7, 15)) + \n    geom_rect(xmin = -7, xmax = 15, ymin = -14, ymax = 7, \n                        fill = \"#FFFFFF00\", col = \"black\") + \n    theme_minimal()\n\n\n## could fix the grid to make these for printing!\n\n## create on-diag rectangles\np1 &lt;- p + geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + A[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - B[2], \n                            fill = \"lightpink\", col = \"pink\") + \n    ylim(c(-10, 7)) +\n    xlim(c(-7, 15)) \n## create off-diag rectangles\np2 &lt;- p1 + geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + B[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - A[2], \n                            fill = \"lavender\", col = \"purple\")\np2 + geom_point(col = \"magenta\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nFifth Tile\n\\[\nM =\n\\begin{bmatrix} 12& 6\\\\ -3 & 1\\end{bmatrix}\n\\]\n\n\nCode\nlibrary(ggplot2)\n## original coordinates\nA &lt;- matrix(c(12, -3), ncol = 1)\nB &lt;- matrix(c(6, 1), ncol = 1)\n\n## coordinates for 4 copies/combos\ncopies &lt;- -10:10\ncoefs &lt;- expand.grid(copies, copies)\n\nx.coords &lt;- coefs$Var1*A[1] + coefs$Var2*B[1]\ny.coords &lt;- coefs$Var1*A[2] + coefs$Var2*B[2]\n\nplot.dat &lt;- data.frame(x = x.coords, y = y.coords)\np &lt;- ggplot(data = plot.dat, aes(x = x, y = y)) +\n    geom_point() + \n    ylim(c(-14, 7)) +\n    xlim(c(-7, 15)) + \n    geom_rect(xmin = -7, xmax = 15, ymin = -14, ymax = 7, \n                        fill = \"#FFFFFF00\", col = \"black\") + \n    theme_minimal()\n\n\n## could fix the grid to make these for printing!\n\n## create on-diag rectangles\np1 &lt;- p + geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + A[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - B[2], \n                            fill = \"lightpink\", col = \"darkred\") + \n    ylim(c(-10, 7)) +\n    xlim(c(-7, 15)) \n## create off-diag rectangles\np2 &lt;- p1 + geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + B[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - A[2], \n                            fill = \"#E0FFFF\", col = \"#A2FFFF\")\np2 + geom_point(col = \"magenta\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nSixth tile\n\n\nCode\nlibrary(ggplot2)\n## original coordinates\nA &lt;- matrix(c(7, 5), ncol = 1)\nB &lt;- matrix(c(6, 2), ncol = 1)\n\n## coordinates for 4 copies/combos\ncopies &lt;- -15:15\ncoefs &lt;- expand.grid(copies, copies)\n\nx.coords &lt;- coefs$Var1*A[1] + coefs$Var2*B[1]\ny.coords &lt;- coefs$Var1*A[2] + coefs$Var2*B[2]\n\nplot.dat &lt;- data.frame(x = x.coords, y = y.coords)\np &lt;- ggplot(data = plot.dat, aes(x = x, y = y)) +\n    geom_point() + \n    ylim(c(-14, 7)) +\n    xlim(c(-7, 15)) + \n    # geom_rect(xmin = -7, xmax = 15, ymin = -14, ymax = 7, \n    #                   fill = \"#FFFFFF00\", col = \"black\") + \n    theme_void()\n\n\n## could fix the grid to make these for printing!\n\n## create on-diag rectangles\np1 &lt;- p +geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + B[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - A[2], \n                            fill = \"#008b8b\", alpha = .1) + \n                            geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + B[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - A[2], \n                            fill = \"#FFFFFF00\", col = \"grey\") +\n                            geom_rect(xmin = plot.dat$x[481], xmax = plot.dat$x[481] + B[1], \n                            ymin = plot.dat$y[481], ymax = plot.dat$y[481] - A[2], \n                            fill = \"#FFFFFF00\", col = \"blue\") +\n                            geom_point(col = \"magenta\") + \n                            ylim(c(-14, 7)) +\n                            xlim(c(-7, 15))\n\n\n\n\nlibrary(patchwork)\np2 &lt;- p + geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + A[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - B[2], \n                            fill = \"yellow\", alpha = .3) +\n                            geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + A[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - B[2], \n                            fill = \"#FFFFFF00\", col = \"grey\") +\n                            geom_rect(xmin = plot.dat$x[481], xmax = plot.dat$x[481] + A[1], \n                            ymin = plot.dat$y[481], ymax = plot.dat$y[481] - B[2], \n                            fill = \"#FFFFFF00\", col = \"orange\")+\n                            geom_point(col = \"magenta\")+ \n                            ylim(c(-14, 7)) +\n                            xlim(c(-7, 15))\n\n## create off-diag rectangles\np_both &lt;- p1 +  geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + A[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - B[2], \n                            fill = \"yellow\", alpha = .2) +\n                            ## outlines\n                            geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + B[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - A[2], \n                            fill = \"#FFFFFF00\", col = \"lightblue\", lwd = 2) +\n                            geom_rect(xmin = plot.dat$x, xmax = plot.dat$x + A[1], \n                            ymin = plot.dat$y, ymax = plot.dat$y - B[2], \n                            fill = \"#FFFFFF00\", col = \"lightyellow\") + \n                            geom_rect(xmin = plot.dat$x[481], xmax = plot.dat$x[481] + B[1], \n                            ymin = plot.dat$y[481], ymax = plot.dat$y[481] - A[2], \n                            fill = \"#FFFFFF00\", col = \"blue\", lwd = 2) +\n                            geom_rect(xmin = plot.dat$x[481], xmax = plot.dat$x[481] + A[1], \n                            ymin = plot.dat$y[481], ymax = plot.dat$y[481] - B[2], \n                            fill = \"#FFFFFF00\", col = \"yellow\") +\n                            geom_point(col = \"magenta\") + \n                            ylim(c(-14, 7)) +\n                            xlim(c(-7, 15))\n## add edges after\np1 + p2 + p_both",
    "crumbs": [
      "Julias first tiles"
    ]
  },
  {
    "objectID": "Construction.html#code-outline",
    "href": "Construction.html#code-outline",
    "title": "1  Construction",
    "section": "1.1 Code outline",
    "text": "1.1 Code outline\nInput:\n\nA \\((2+k) \\times (2 +k)\\) matrix \\(M\\)\n\\(k\\)\n\n\n## random values\nset.seed(5)\nk &lt;- 3\nvals &lt;- rpois((2+k)^2,2)\nM &lt;- matrix(vals, nrow = 2+k)\nM\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    1    1    4\n[2,]    3    2    2    1    3\n[3,]    4    3    1    4    1\n[4,]    1    5    2    2    1\n[5,]    0    0    1    3    1\n\n# ## Alex's values\n# M &lt;- matrix(c(2,6,3,-5, 1, \n#                           3,1,-3,-5,8,\n#                           -4,8,4,4,1,\n#                           2,0,6,2,2,\n#                           5,4,0,3,2\n# ), nrow = 5);M\n# k &lt;- nrow(M)-2;k\n\nStep 1\n\nCreate three new matrices:\n\n\\(M_{TOP}\\) is the \\(2 \\times (2+k)\\) matrix consisting of the first two rows of \\(M\\)\n\\(M_{BOT}\\) is the \\(k \\times (2+k)\\) matrix consisting of the remaining \\(k\\) rows of \\(M\\)\n\\(M'\\) is the \\((2+k) \\times (2 +k)\\) matrix created by stacking \\(M_{TOP}\\) and \\(-M_{BOT}\\)\n\n\n\nM_top &lt;- M[1:2,]; M_top\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    1    1    4\n[2,]    3    2    2    1    3\n\nM_bot &lt;- M[3:(2+k),]; M_bot\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    4    3    1    4    1\n[2,]    1    5    2    2    1\n[3,]    0    0    1    3    1\n\nM_prime &lt;- rbind(M_top, -1*M_bot); M_prime\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    1    1    4\n[2,]    3    2    2    1    3\n[3,]   -4   -3   -1   -4   -1\n[4,]   -1   -5   -2   -2   -1\n[5,]    0    0   -1   -3   -1\n\n\nStep 2\n\nFor each \\(\\sigma \\in \\binom{[2+k]}{2}\\), define \\(S_{\\sigma}(M)\\) as follows:\n\n\n\n\n\n\nNotation: \\(\\binom{[n]}{k}\\)\n\n\n\n\n\nThe notation is shorthand for the set of all subsets of \\(\\{1, 2, \\dots, n\\}\\) of size \\(k\\).\nFor example, if \\(n = 3\\) and \\(k=2\\), \\[\\binom{[n]}{k} =  \\binom{[3]}{2} = \\{\\{1,2\\}, \\{1,3\\}, \\{2,3\\}\\}\\]\n\n\n\n\nStart with \\(M'\\),\n\nConsider \\(i^{th}\\) column for \\(i \\in \\{1, 2, \\dots, k+2\\}\\). If :\n\n\\(i \\in \\sigma\\): zero out bottom \\(k\\) entries\n\\(i \\not\\in \\sigma\\): zero out the top 2 entries\n\n\n\n\n\nsig &lt;- combn(2+k, 2)\n#n_sig &lt;- .5*k^2 + 1.5*k + 1 \nn_sig &lt;- ncol(sig)\nS_sig &lt;- replicate(n_sig, M_prime)\n\nfor(j in 1:n_sig){\n    for(i in 1:(2+k)){\n        if(i %in% sig[,j]){\n                S_sig[3:(2+k),i,j]&lt;- 0\n        }\n    else{\n                S_sig[1:2,i,j]&lt;- 0\n    }\n}\n}\n\n# ## sig[,7] corresponds to \\sigma = \\{2,5\\}\n# S_sig[,,7]\n# \n# ## sig[,6] corresponds to \\sigma = \\{2,4\\}\n# S_sig[,,6]\n\n\n\n\nHere, \\(k = 3\\) and \\(\\sigma = \\{2, 5\\}\\).\n\n\n\nAfter this process, you will end up with \\(\\frac{1}{2}k^2 + \\frac{3}{2}k + 1\\) matrices\n\nStep 3\nConsider the matrices \\(\\{S_\\sigma\\}\\). Each of these matrices corresponds to a \\(2+k\\)-dimensional shape (the fundamental parallelepiped \\(\\Pi \\left ( S_\\sigma\\right )\\) defined by the columns of that matrix).\n\n\n\n\n\n\nThe fundamental parallelepiped \\(\\Pi(S_\\sigma)\\)\n\n\n\n\n\nNote that\n\\[\\Pi \\left ( S_\\sigma\\right ) = \\{S_\\sigma \\cdot (x_1, \\dots, x_{k+2})'\\}\\] Think of the \\(x_i\\) as representing the interval \\([0,1]\\), so that you are getting a shape. In other words, \\(\\Pi\\) is the Minkowski sum of the columns of \\(S_\\sigma\\).\n\n\n\nFor each \\(\\sigma\\), want to visualize a collection of parallelepipeds, \\(\\Pi \\left ( S_\\sigma\\right ) + Mz\\), where \\(z \\in \\mathbb{Z}^{k+2}\\). (FIXME: in practice we won’t want to generate individual plots because there will be too many, we just want to emphasize a given \\(S_\\sigma\\) in the plots discussed next.)\nThe desired end product is to create two visualizations: one of all positive \\(S_\\sigma\\) and one of all negative \\(S_\\sigma\\).\n\n\n\n\n\n\nWhat about \\(det(S_\\sigma) = 0\\)?\n\n\n\n\n\nThe determinant measures volume. So, in this case, the volume of the parallelepiped is 0, so there is nothing to visualize.\n\nS_dets &lt;- apply(S_sig, 3, det)\nS_dets == 0\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nsum(S_dets&gt;0)\n\n[1] 6\n\n\n\n\n\nAlso, that parallelepiped is more than 3D so there will need to be a choice made in which slices to take for visualization.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Construction outline</span>"
    ]
  }
]